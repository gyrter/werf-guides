## Важность неизменяемой сборки

Довольно часто возникают такие ситуации, когда разработчики на Node.js c помощью переменных или конфигов создают несколько режимов сборки приложения. И в зависимости от этих переменных их приложение может при сборке по-разному генерировать статичные объекты, например, ссылки внутри веб-страниц. Такой подход безусловно удобен для локальной разработки, но мы крайне не рекомендуем использовать его внутри вашего CI/CD. Образ, попадающий в кластер (в любое из окружений), должен быть абсолютно одинаковым. И мы знаем, что у некоторых людей может возникнуть вопрос «Почему?».

Потому что Docker image между окружениями должен быть неизменяемым. Только так мы можем всегда быть уверенными в сборке: если образ, оттестированный на stage-окружении, попадет в production **точно таким же**. Для всего остального мира наше приложение должно быть чёрным ящиком, которое может лишь принимать параметры.

Если же вам необходимо иметь внутри кода ссылки или любые другие изменяемые между окружениями объекты, это реализуется несколькими способами:

1. Можно динамически, в зависимости от окружения, монтировать в контейнер с приложением JSON с нужными параметрами. Для этого потребуется создать объект ConfigMap в `.helm/templates`:

**10-app-config.yaml**

{% raw %}
```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Chart.Name }}-config
data:
  config.json: |-
   {
    "domain": "{{ pluck .Values.global.env .Values.domain | first }}",
    "loginUrl": "{{ pluck .Values.global.env .Values.loginUrl | first }}"
   }
```
{% endraw %}

… а затем примонтировать его к приложению в то место, где можно получать его по запросу от клиента: \
Код из 01-app.yaml:


{% raw %}
```yaml
       volumeMounts:
          - name: app-config
            mountPath: /app/dist/config.json
            subPath: config.json
      volumes:
        - name: app-config
          configMap:
            name: {{ .Chart.Name }}-config
```
{% endraw %}

После того, как конфиг окажется внутри приложения, можно обращаться к нему как обычно.

2. Перед запуском приложения получать конфиги из внешнего ресурса, например, из [consul](https://www.consul.io/). Подробное описание этого варианта выходит за рамки самоучителя, но дадим два совета:

*   Можно запускать его перед запуском приложения, добавив прямо в манифесте, описывающем приложение, в `command: ["node","/app/src/js/server.js"]` его запуск через `&&`, как в синтаксисе любого shell-языка:
{% raw %}
```yaml
command:
- /usr/bin/bash
- -c
- --
- "consul kv get app/config/urls && node /app/src/js/server.js"]
```
{% endraw %}


*   Можно добавить его запуск в [init-container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/), подключив между init-контейнером и основным контейнером общий [volume](https://kubernetes.io/docs/concepts/storage/volumes/). Это означает, что нужно просто смонтировать volume в оба контейнера (например, [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir)). Тогда consul, отработав в init-контейнере, сохранит конфиг в volume, а приложение из основного контейнера просто заберёт этот конфиг.
